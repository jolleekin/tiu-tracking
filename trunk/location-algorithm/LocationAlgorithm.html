<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Visulation of Location Algorithms</title>

  <script type="application/x-javascript">
		
		/* Vector2D */

		function Vector2D() {
			this.x = 0;
			this.y = 0;
		}
		
		function Vector2D(x, y) {
			this.x = x;
			this.y = y;
		}
		
		Vector2D.prototype.length = function () {
			return Math.sqrt(this.x*this.x + this.y*this.y);
		}

		Vector2D.prototype.squaredLength = function () {
			return this.x*this.x + this.y*this.y;
		}

		Vector2D.prototype.distanceTo = function (other) {
			var dx = this.x - other.x;
			var dy = this.y - other.y;
			return Math.sqrt(dx*dx + dy*dy);
		}

		Vector2D.prototype.lerp = function (other, factor) {
			var x = this.x + factor * (other.x - this.x);
			var y = this.y + factor * (other.y - this.y);
			return new Vector2D(x, y);
		}

		Vector2D.prototype.dotProduct = function (other) {
			return this.x * other.x + this.y * other.y;
		}
		
		// static
		Vector2D.difference = function (v1, v2) {
			return new Vector2D(v1.x - v2.x, v1.y - v2.y);
		}

		// static
		Vector2D.sum = function (v1, v2) {
			return new Vector2D(v1.x + v2.x, v1.y + v2.y);
		}
		
		/* End of Vector2D */
				
		var t = 20;
		var l = 20;
		var w = 1000;
		var h = 600;
		var maxNoise = 200;
		var pointRadius = 5;
		var TWO_PI = 2 * Math.PI;
		
		var actualAssetLocation = new Vector2D();
		var estimatedAssetLocation = new Vector2D();
		var distances = [0, 0, 0, 0];
		
		var detectors = [
			new Vector2D(l, t),
			new Vector2D(w, t),
			new Vector2D(l, h),
			new Vector2D(w, h)
		];
				
		var ctx = null;		// rendering context
				
		var state = {
			isPanning: false,
			posX: 0,
			posY: 0,
			translateX: 0,
			translateY: 0,
			scale: 1
		}
		
		var n1 = Vector2D.difference(detectors[3], detectors[0]);
		var n2 = Vector2D.difference(detectors[2], detectors[1]);		
		var p1 = new Vector2D();
		var p2 = new Vector2D();
		
		function randomizeAndEstimate() {
			actualAssetLocation.x = l + Math.random() * w;
			actualAssetLocation.y = t + Math.random() * h;	
			
			/* Version 1 */
			
			// Model measured distances by adding noise to the actual distances
			// The formula may be changed to better approximate noise in reality
			for (var i = 0; i < detectors.length; i++) {
				distances[i] = actualAssetLocation.distanceTo(detectors[i]) + Math.random() * maxNoise;
			}

			var l1 = n1.length();
			var l2 = n2.length();
			var factor1 = (distances[0] - 0.5 * (distances[0] + distances[3] - l1)) / l1;
			var factor2 = (distances[1] - 0.5 * (distances[1] + distances[2] - l2)) / l2;
			p1 = detectors[0].lerp(detectors[3], factor1);
			p2 = detectors[1].lerp(detectors[2], factor2);
			
			/* Version 2 */
			/*
			var d = [];			
			for (var i = 0; i < detectors.length; i++) {
				distances[i] = actualAssetLocation.distanceTo(detectors[i]) + Math.random() * maxNoise;
				d.push(Math.pow(distances[i], 1.4));
			}
			
			p1 = detectors[0].lerp(detectors[3], d[0] / (d[0] + d[3]));
			p2 = detectors[1].lerp(detectors[2], d[1] / (d[1] + d[2]));
			*/
			
			// Common part: Solving the set of 2 equations
			// [p - p1] dot n1 = 0
			// [p - p2] dot n2 = 0
			
			var c1 = p1.dotProduct(n1);
			var c2 = p2.dotProduct(n2);
			var det = n1.x * n2.y - n2.x * n1.y;
			var detX = c1 * n2.y - c2 * n1.y;
			var detY = n1.x * c2 - n2.x * c1;
			estimatedAssetLocation.x = detX / det;
			estimatedAssetLocation.y = detY / det;			
			
			// Check if the estimate location lies within the common region of all the circles
			// If not, move the location into the common region
			for (var i = 0; i < detectors.length; i++) {
				var d = estimatedAssetLocation.distanceTo(detectors[i])
				if ( d > distances[i]) {
					estimatedAssetLocation = detectors[i].lerp(estimatedAssetLocation, 0.9 * distances[i] / d);
				}
			}
		}
		
		function runTest() {
			var count = parseInt(txtCount.value, 10);
			if (count > 1) {
				var error = 0;
				var mean = 0;
				var deviation = 0;
				var min = 10000;
				var max = 0;
				var gt150 = 0;
				for (var i = 0; i < count; i++) {
					randomizeAndEstimate();
					error = actualAssetLocation.distanceTo(estimatedAssetLocation);
					mean += error;
					deviation += error * error;
					if (error < min) {
						min = error;
					} else if (error > max) {
						max = error;
					}
					if (error > 150) {
						gt150++;
					}
				}
				mean /= count;
				deviation = Math.sqrt(deviation / count - mean*mean);
				txtMin.value = Math.round(min);
				txtMax.value = Math.round(max);
				txtMean.value = Math.round(mean);
				txtDeviation.value = Math.round(deviation);
				txtGreaterThan150.value = gt150;
			} else if (count ==  1) {
				randomizeAndEstimate();
				txtMin.value = '';
				txtMax.value = '';
				txtMean.value = '';
				txtDeviation.value = '';
				txtGreaterThan150.value = '';
			}
			draw();
		}
		
		function draw() {			
			ctx.save();
			ctx.fillStyle = 'white';
			ctx.fillRect(0, 0, canvas.width, canvas.height);		
			
			ctx.translate(state.translateX, state.translateY);
			ctx.scale(state.scale, state.scale);
			ctx.font = Math.round(16 / state.scale) + 'px Courier New';
			
			ctx.beginPath();
			ctx.fillStyle = 'green';
			for (var i = 0; i < detectors.length; i++) {
				ctx.arc(detectors[i].x, detectors[i].y, pointRadius, 0, TWO_PI, true);
			}
			ctx.fill();
			
			ctx.strokeStyle = '#cc9999';
			for (var i = 0; i < detectors.length; i++) {
				ctx.beginPath();
				ctx.arc(detectors[i].x, detectors[i].y, distances[i], 0, TWO_PI, true);
				ctx.stroke();
			}
			
			ctx.strokeStyle = 'green';
			ctx.beginPath();
			ctx.moveTo(detectors[0].x, detectors[0].y);
			ctx.lineTo(detectors[3].x, detectors[3].y);
			ctx.moveTo(detectors[1].x, detectors[1].y);
			ctx.lineTo(detectors[2].x, detectors[2].y);
			ctx.stroke();
			
			
			ctx.beginPath();
			ctx.fillStyle = 'red';
			ctx.arc(actualAssetLocation.x, actualAssetLocation.y, pointRadius, 0, 2 * Math.PI, true);
			ctx.fill();
			ctx.fillText('Actual', actualAssetLocation.x + 5, actualAssetLocation.y - 5);

			ctx.beginPath();
			ctx.fillStyle = 'rgb(100, 100, 100)';
			ctx.arc(p1.x, p1.y, pointRadius, 0, TWO_PI, true);
			ctx.arc(p2.x, p2.y, pointRadius, 0, TWO_PI, true);
			ctx.fill();
							
			ctx.beginPath();
			ctx.strokeStyle = 'blue';
			ctx.moveTo(p1.x, p1.y);
			ctx.lineTo(estimatedAssetLocation.x, estimatedAssetLocation.y);
			ctx.lineTo(p2.x, p2.y);
			ctx.stroke();
			
			ctx.beginPath();
			ctx.fillStyle = 'rgb(0, 0, 255)';
			ctx.arc(estimatedAssetLocation.x, estimatedAssetLocation.y, pointRadius, 0, TWO_PI, true);
			ctx.fill();
			ctx.fillText('Estimated', estimatedAssetLocation.x + 5, estimatedAssetLocation.y - 5);
			
			ctx.beginPath();
			ctx.fillStyle = 'yellow';
			
			ctx.fill();
			
			ctx.restore();
			
			ctx.fillStyle = 'Black';
			ctx.fillText('Error = ' + Math.round(actualAssetLocation.distanceTo(estimatedAssetLocation)).toString(10) + 'cm', l + 0.4 * w, 2 * t);
		}
				
		function init() {
			canvas.onmousedown = function (e) {
				if (e.button == 0) {
					this.style.cursor = 'move';
					state.isPanning = true;
					state.posX = e.layerX;
					state.posY = e.layerY;
				}
				return false;
			}
			
			canvas.onmouseup = function (e) {
				state.isPanning = false;
				this.style.cursor = 'default';
				return false;
			}
			
			canvas.onmousemove = function (e) {
				if (state.isPanning) {
					state.translateX += e.layerX - state.posX;
					state.translateY += e.layerY - state.posY;
					state.posX = e.layerX;
					state.posY = e.layerY;
					draw();
				}
				return false;
			}
			
			canvas.onmousewheel = function (e) {
				var delta = e.detail ? e.detail : e.wheelDelta / 120;
				delta *= 0.1;
				if (((delta > 0) && (state.scale < 4)) || ((delta < 0) && (state.scale > 0.3))) {
					var x = (e.layerX - this.offsetLeft - state.translateX) / state.scale;
					var y = (e.layerY - this.offsetTop  - state.translateY) / state.scale;
					state.translateX -= delta * x;
					state.translateY -= delta * y;
					state.scale += delta;
					ctx.lineWidth = 1 / state.scale;
					pointRadius = 5 / state.scale;
					draw();
				}
				return false;
			}
			
			canvas.width  = 2 * l + w;
			canvas.height = 2 * t + h;
			ctx = canvas.getContext('2d');
			ctx.font = '16px Courier New';
			randomizeAndEstimate();
			draw();
		}
	</script>
	
	<style type="text/css">
		input { width: 60px;}
	</style>
</head>
<body onload="init()" style="width: 100%; background-color: #abefcd;">
	<div style="float: left; width: 200px;">
		Count = <input type="text" id="txtCount" value="1" /><button id="btnRun" onclick="runTest();">Run</button><br />
		Min = <input type="text" id="txtMin" value="" /><br />
		Max = <input type="text" id="txtMax" value="" /><br />
		Mean = <input type="text" id="txtMean" value="" /><br />
		Deviation = <input type="text" id="txtDeviation" value="" /><br >
		> 150cm <input type="text" id="txtGreaterThan150" value="" /><br />
	</div>
	<div style="float: left; width: 1030;">
	<canvas id="canvas" width="1020" height="620" style="border: 1px solid Grey;">
		<p>This example requires a browser that supports the
		<a href="http://www.w3.org/html/wg/html5/">HTML5</a> 
		&lt;canvas&gt; feature.
		</p>
	</canvas>
	</div>
</body>
</html>
